-- controle reacteur fission v0.6.2
-- monitor: monitor_9
-- reactor: fissionReactorLogicAdapter_1
-- auto lever: redstone input on FRONT
-- changes:
-- 1) auto off => reactor off (scram + burn 0)
-- 2) auto on + cleared lock + passed relight threshold => reactor on (activate)
-- 3) coolant regulation: min=30% target=33%

-------------------------
-- config
-------------------------
local MONITOR_NAME = "monitor_9"
local REACTOR_NAME = "fissionReactorLogicAdapter_1"

local TEXT_SCALE = 1.8
local LOOP_SEC = 0.5

local AUTO_SIDE = "front"
local AUTO_DEFAULT = true

local COOL_TARGET = 0.33
local COOL_LOW = 0.30
local COOL_HIGH = 0.80

local MIN_BURN = 0.20
local MAX_BURN = 375.00

local RAMP_UP = 1.5
local RAMP_DOWN = 3.0
local STABLE_BONUS = 0.25
local STABLE_EPS = 0.001

local DAMAGE_LOCK = 30.0
local TEMP_LOCK_C = 1200.0
local HEATED_LOCK = 0.95
local WASTE_LOCK = 0.95

-- relight thresholds (must be met to auto-activate after a lock)
local RELIGHT_DAMAGE = 25.0
local RELIGHT_TEMP_C = 800.0
local RELIGHT_HEATED = 0.80
local RELIGHT_WASTE = 0.80

-------------------------
-- helpers
-------------------------
local function clamp(x, a, b)
  if x < a then return a end
  if x > b then return b end
  return x
end

local function fmtNum(x, decimals)
  if type(x) ~= "number" then return "n/a" end
  local m = 10 ^ (decimals or 0)
  local v = math.floor(x * m + 0.5) / m
  return tostring(v)
end

local function safeCall(fn)
  local ok, res = pcall(fn)
  if ok then return true, res end
  return false, nil
end

local function bar(pct, width)
  if type(pct) ~= "number" then
    return "[" .. string.rep("-", width) .. "]"
  end
  pct = clamp(pct, 0, 1)
  local fill = math.floor(pct * width + 0.5)
  fill = clamp(fill, 0, width)
  return "[" .. string.rep("#", fill) .. string.rep("-", width - fill) .. "]"
end

-------------------------
-- peripherals
-------------------------
local mon = peripheral.wrap(MONITOR_NAME)
if not mon then error("monitor introuvable: " .. tostring(MONITOR_NAME)) end
mon.setTextScale(TEXT_SCALE)

local reactor = peripheral.wrap(REACTOR_NAME)
if not reactor then
  reactor = peripheral.find("fissionReactorLogicAdapter")
end
if not reactor then error("reacteur introuvable (type fissionReactorLogicAdapter)") end

local reactorDisplayName = peripheral.getName(reactor) or REACTOR_NAME

-------------------------
-- ui sans clignotement
-------------------------
local lastCell = {}

local function cellKey(x, y, fg, bg)
  return tostring(x) .. "," .. tostring(y) .. ":" .. tostring(fg) .. ":" .. tostring(bg)
end

local function writeAt(x, y, text, fg, bg)
  local w, h = mon.getSize()
  if y < 1 or y > h then return end
  if x < 1 then x = 1 end
  text = tostring(text or "")
  if bg then mon.setBackgroundColor(bg) end
  if fg then mon.setTextColor(fg) end

  local k = cellKey(x, y, fg, bg)
  if lastCell[k] == text then return end
  lastCell[k] = text

  mon.setCursorPos(x, y)
  mon.write(text)
end

local function clearAll()
  mon.setBackgroundColor(colors.black)
  mon.clear()
  lastCell = {}
end

-------------------------
-- control
-------------------------
local burnCmd = MIN_BURN
local lastCoolPct = nil
local locked = false
local lockReason = "-"

local function setBurn(rate)
  rate = clamp(rate, 0, MAX_BURN)
  safeCall(function() reactor.setBurnRate(rate) end)
end

local function reactorOff()
  setBurn(0)
  safeCall(function() reactor.scram() end)
end

local function reactorOn()
  safeCall(function() reactor.activate() end)
end

local function scramNow(reason)
  locked = true
  lockReason = reason or "verrouillage"
  reactorOff()
end

local function readAuto()
  local ok = pcall(function() return redstone.getInput(AUTO_SIDE) end)
  if ok then return redstone.getInput(AUTO_SIDE) end
  return AUTO_DEFAULT
end

local function pctTxt(v)
  if type(v) == "number" then return fmtNum(v * 100, 1) .. "%" end
  return "n/a"
end

local function statusColor(isOn)
  if isOn == true then return colors.lime end
  if isOn == false then return colors.red end
  return colors.lightGray
end

local function yesNoColor(v)
  if v == true then return colors.lime end
  if v == false then return colors.red end
  return colors.lightGray
end

local function relightOk(tempC, dmgPct, heatedPct, wastePct)
  if type(dmgPct) ~= "number" or dmgPct > RELIGHT_DAMAGE then return false end
  if type(tempC) ~= "number" or tempC > RELIGHT_TEMP_C then return false end
  if type(heatedPct) ~= "number" or heatedPct > RELIGHT_HEATED then return false end
  if type(wastePct) ~= "number" or wastePct > RELIGHT_WASTE then return false end
  return true
end

clearAll()

-------------------------
-- main loop
-------------------------
while true do
  local w, h = mon.getSize()
  local barW = clamp(w - 20, 10, 60)

  local auto = readAuto()

  local okState, state = safeCall(function() return reactor.getStatus() end)
  local okTemp, tempK = safeCall(function() return reactor.getTemperature() end)
  local okHeatRate, heatRate = safeCall(function() return reactor.getHeatingRate() end)
  local okDamage, dmgPct = safeCall(function() return reactor.getDamagePercent() end)

  local okCoolPct, coolPct = safeCall(function() return reactor.getCoolantFilledPercentage() end)
  local okFuelPct, fuelPct = safeCall(function() return reactor.getFuelFilledPercentage() end)
  local okWastePct, wastePct = safeCall(function() return reactor.getWasteFilledPercentage() end)
  local okHeatedPct, heatedPct = safeCall(function() return reactor.getHeatedCoolantFilledPercentage() end)

  local okCoolTbl, coolTbl = safeCall(function() return reactor.getCoolant() end)
  local coolantName = "n/a"
  if okCoolTbl and type(coolTbl) == "table" and coolTbl.name then
    coolantName = tostring(coolTbl.name)
  end

  local okBurn, burnNow = safeCall(function() return reactor.getBurnRate() end)
  local okMaxBurn, maxBurn = safeCall(function() return reactor.getMaxBurnRate() end)

  local tempC = nil
  if okTemp and type(tempK) == "number" then
    tempC = tempK - 273.15
  end

  -- auto off => force reactor off (and reset ramp memory)
  if not auto then
    locked = false
    lockReason = "-"
    burnCmd = MIN_BURN
    lastCoolPct = nil
    reactorOff()
  end

  -- safety locks (only when auto is on)
  if auto and (not locked) then
    if okDamage and type(dmgPct) == "number" and dmgPct >= DAMAGE_LOCK then
      scramNow("degats")
    elseif type(tempC) == "number" and tempC >= TEMP_LOCK_C then
      scramNow("temperature")
    elseif okHeatedPct and type(heatedPct) == "number" and heatedPct >= HEATED_LOCK then
      scramNow("chauffe")
    elseif okWastePct and type(wastePct) == "number" and wastePct >= WASTE_LOCK then
      scramNow("dechets")
    end
  end

  -- relight: if locked and now safe again, clear lock and start reactor
  if auto and locked then
    local ok = relightOk(tempC, dmgPct, heatedPct, wastePct)
    if ok then
      locked = false
      lockReason = "-"
      burnCmd = MIN_BURN
      setBurn(burnCmd)
      reactorOn()
    else
      reactorOff()
    end
  end

  -- ensure reactor on when auto on and not locked
  if auto and (not locked) and okState and state == false then
    reactorOn()
  end

  -- regulation burn (coolant based) only when auto on and not locked
  if auto and (not locked) and okCoolPct and type(coolPct) == "number" then
    local dCool = 0
    if type(lastCoolPct) == "number" then
      dCool = coolPct - lastCoolPct
    end
    lastCoolPct = coolPct

    local stable = math.abs(dCool) <= STABLE_EPS
    local delta = 0

    if coolPct < COOL_LOW then
      local severity = (COOL_LOW - coolPct) / COOL_LOW
      delta = -RAMP_DOWN * (0.5 + severity)
    elseif coolPct < COOL_TARGET then
      local severity = (COOL_TARGET - coolPct) / (COOL_TARGET - COOL_LOW)
      delta = -RAMP_DOWN * 0.5 * severity
    else
      local gain = 1.0
      if coolPct > COOL_HIGH then gain = 0.6 end
      if stable then
        delta = (RAMP_UP * 0.4 * gain) + STABLE_BONUS
      else
        if dCool > 0 then
          delta = RAMP_UP * 1.0 * gain
        else
          delta = RAMP_UP * 0.3 * gain
        end
      end
    end

    burnCmd = clamp(burnCmd + delta, MIN_BURN, MAX_BURN)
    setBurn(burnCmd)
  end

  -- numeric capacities
  local okCoolCap, coolCap = safeCall(function() return reactor.getCoolantCapacity() end)
  local okFuelCap, fuelCap = safeCall(function() return reactor.getFuelCapacity() end)
  local okWasteCap, wasteCap = safeCall(function() return reactor.getWasteCapacity() end)
  local okHeatCap, heatCap = safeCall(function() return reactor.getHeatedCoolantCapacity() end)

  local coolAmt = (okCoolPct and okCoolCap and type(coolPct)=="number" and type(coolCap)=="number") and (coolPct * coolCap) or nil
  local fuelAmt = (okFuelPct and okFuelCap and type(fuelPct)=="number" and type(fuelCap)=="number") and (fuelPct * fuelCap) or nil
  local wasteAmt = (okWastePct and okWasteCap and type(wastePct)=="number" and type(wasteCap)=="number") and (wastePct * wasteCap) or nil
  local heatAmt = (okHeatedPct and okHeatCap and type(heatedPct)=="number" and type(heatCap)=="number") and (heatedPct * heatCap) or nil

  -- display
  writeAt(1, 1, "controle reacteur fission", colors.cyan, colors.black)
  writeAt(1, 2, reactorDisplayName, colors.lightGray, colors.black)

  writeAt(1, 3, "etat:", colors.white, colors.black)
  local etatTxt = "n/a"
  if okState then etatTxt = state and "marche" or "arret" end
  writeAt(7, 3, string.upper(etatTxt), statusColor(okState and state or nil), colors.black)

  writeAt(17, 3, "auto:", colors.white, colors.black)
  writeAt(23, 3, auto and "OUI" or "NON", yesNoColor(auto), colors.black)

  writeAt(1, 4, "temp:", colors.white, colors.black)
  local tempTxt = (type(tempC)=="number") and (fmtNum(tempC,1) .. " C") or "n/a"
  writeAt(7, 4, tempTxt, colors.orange, colors.black)

  writeAt(17, 4, "chauffe:", colors.white, colors.black)
  local heatTxt = (okHeatRate and type(heatRate)=="number") and (fmtNum(heatRate,2) .. " MB/T") or "n/a"
  writeAt(26, 4, heatTxt, colors.orange, colors.black)

  writeAt(1, 5, "coolant:", colors.white, colors.black)
  writeAt(10, 5, coolantName, colors.lightBlue, colors.black)

  writeAt(30, 5, "burn:", colors.white, colors.black)
  local burnTxt = okBurn and type(burnNow)=="number" and fmtNum(burnNow,2) or fmtNum(burnCmd,2)
  local maxBurnTxt = okMaxBurn and type(maxBurn)=="number" and fmtNum(maxBurn,0) or fmtNum(MAX_BURN,0)
  writeAt(36, 5, burnTxt .. "/" .. maxBurnTxt, colors.yellow, colors.black)

  writeAt(1, 6, "verrouillage:", colors.white, colors.black)
  writeAt(15, 6, locked and "OUI" or "NON", locked and colors.red or colors.lime, colors.black)
  if locked then
    writeAt(20, 6, "(" .. lockReason .. ")", colors.red, colors.black)
  end
  writeAt(34, 6, "cible coolant:", colors.white, colors.black)
  writeAt(48, 6, fmtNum(COOL_TARGET*100,0) .. "%", colors.lightBlue, colors.black)

  writeAt(1, 8,  "COOLANT " .. bar(okCoolPct and coolPct or nil, barW), colors.lightBlue, colors.black)
  writeAt(10 + barW, 8, " " .. pctTxt(okCoolPct and coolPct or nil), colors.lightBlue, colors.black)

  writeAt(1, 9,  "FUEL    " .. bar(okFuelPct and fuelPct or nil, barW), colors.lime, colors.black)
  writeAt(10 + barW, 9, " " .. pctTxt(okFuelPct and fuelPct or nil), colors.lime, colors.black)

  writeAt(1, 10, "DECHETS " .. bar(okWastePct and wastePct or nil, barW), colors.purple, colors.black)
  writeAt(10 + barW, 10, " " .. pctTxt(okWastePct and wastePct or nil), colors.purple, colors.black)

  writeAt(1, 11, "CHAUFFE " .. bar(okHeatedPct and heatedPct or nil, barW), colors.yellow, colors.black)
  writeAt(10 + barW, 11, " " .. pctTxt(okHeatedPct and heatedPct or nil), colors.yellow, colors.black)

  local function amtLine(label, amt, cap, color, y)
    writeAt(1, y, label, color, colors.black)
    if type(amt)=="number" and type(cap)=="number" then
      writeAt(10, y, fmtNum(amt,0) .. "/" .. fmtNum(cap,0) .. " MB", color, colors.black)
    else
      writeAt(10, y, "n/a", colors.lightGray, colors.black)
    end
  end

  amtLine("coolant:", coolAmt, (okCoolCap and coolCap or nil), colors.lightBlue, 13)
  amtLine("fuel:",    fuelAmt, (okFuelCap and fuelCap or nil), colors.lime, 14)
  amtLine("dechets:", wasteAmt,(okWasteCap and wasteCap or nil), colors.purple, 15)
  amtLine("chauffe:", heatAmt, (okHeatCap and heatCap or nil), colors.yellow, 16)

  local dmgTxt = (okDamage and type(dmgPct)=="number") and (fmtNum(dmgPct,1) .. "%") or "n/a"
  writeAt(1, 18, "degats: " .. dmgTxt .. " | limite burn: " .. fmtNum(MAX_BURN,0) .. " MB", colors.white, colors.black)

  sleep(LOOP_SEC)
end
```0