-- reactor_code_v0_4.lua
-- cc:tweaked + mekanism fission reactor logic adapter
-- fixed: correct method names (case sensitive), stable screen (no flicker), bars back, auto safeties + alarms

-- =========================
-- config (edit if needed)
-- =========================
local REACTOR_NAME = "fissionReactorLogicAdapter_0"
local MONITOR_NAME = "monitor_7"      -- your 7x6 monitor is monitor_7
local AUTO_SIDE    = "left"           -- lever for auto mode

local LOOP_SEC     = 0.25

-- burn control by coolant (keep min 10%)
local COOLANT_FULL = 0.80            -- 80% -> allow burn max
local COOLANT_LOW  = 0.10            -- 10% -> burn minimum
local MIN_BURN_FRAC = 0.10           -- 10% of max burn
local RAMP_STEP_FRAC = 0.20          -- max change per loop (20% of max burn)

-- safeties (percent are 0..1)
local COOL_STOP   = 0.05
local COOL_RESET  = 0.80

local TEMP_STOP_C  = 800
local TEMP_RESET_C = 100

local HEAT_STOP   = 0.80
local HEAT_RESET  = 0.00

local WASTE_STOP  = 0.80
local WASTE_RESET = 0.50

local DAMAGE_LOCK_PCT = 30           -- absolute lock if damage percent > 30

-- alarm
local ALARM_FORCE_SEC = 3

-- =========================
-- helpers
-- =========================
local function clamp(x, a, b)
  if x == nil then return nil end
  if x < a then return a end
  if x > b then return b end
  return x
end

local function safe_call(obj, method, ...)
  if not obj or not method then return nil end
  local fn = obj[method]
  if type(fn) ~= "function" then return nil end
  local ok, res = pcall(fn, obj, ...)
  if not ok then return nil end
  return res
end

local function pct_from_filled_capacity(obj, filled_m, cap_m)
  local filled = safe_call(obj, filled_m)
  local cap    = safe_call(obj, cap_m)
  if type(filled) == "number" and type(cap) == "number" and cap > 0 then
    return clamp(filled / cap, 0, 1), filled, cap
  end
  return nil, filled, cap
end

local function get_pct(obj, filled_m, cap_m, pct_m)
  -- prefer filled/capacity (works on your mekanism)
  local p, filled, cap = pct_from_filled_capacity(obj, filled_m, cap_m)
  if p ~= nil then return p, filled, cap end

  -- fallback if some packs expose *_FilledPercentage
  local pp = safe_call(obj, pct_m)
  if type(pp) == "number" then
    -- some return 0..1, some 0..100
    if pp > 1.0 then pp = pp / 100 end
    return clamp(pp, 0, 1), nil, nil
  end

  return nil, filled, cap
end

local function fmt_pct(p)
  if type(p) ~= "number" then return "n/a" end
  return string.format("%.1f%%", p * 100)
end

local function k_to_c(k)
  if type(k) ~= "number" then return nil end
  return k - 273.15
end

local function bar(p, w)
  if type(p) ~= "number" then
    return string.rep("-", w)
  end
  p = clamp(p, 0, 1)
  local fill = math.floor(p * w + 0.5)
  if fill < 0 then fill = 0 end
  if fill > w then fill = w end
  return string.rep("#", fill) .. string.rep("-", w - fill)
end

-- =========================
-- peripherals
-- =========================
local reactor = peripheral.wrap(REACTOR_NAME)
if not reactor then error("no reactor found: " .. REACTOR_NAME) end

local mon = peripheral.wrap(MONITOR_NAME)
if not mon then
  mon = peripheral.find("monitor")
end
if not mon then error("no monitor found") end

-- pick first speaker if any
local speaker = peripheral.find("speaker")

-- stable drawing: redirect to monitor, but do not clear each loop
term.redirect(mon)
mon.setTextScale(0.5) -- fits more text; change to 1.0 if you want bigger

local W, H = mon.getSize()

-- colors helper
local function cwrite(x, y, col, txt)
  term.setCursorPos(x, y)
  term.setTextColor(col)
  term.write(txt)
end

local function clear_line(y)
  term.setCursorPos(1, y)
  term.setTextColor(colors.white)
  term.write(string.rep(" ", W))
end

-- =========================
-- alarms
-- =========================
local alarm_force_until = 0
local alarm_locked = false

local function speaker_beep_once()
  if not speaker then return end
  -- safe sound
  pcall(speaker.playSound, "minecraft:block.note_block.pling", 2.0, 1.0)
end

local function update_alarm(now)
  if alarm_locked then
    -- continuous beep
    speaker_beep_once()
    return
  end
  if now < alarm_force_until then
    speaker_beep_once()
  end
end

-- =========================
-- state machine
-- =========================
local locked_trip = false
local trip_cause = "-"
local forced_trip = false

local function set_trip(cause, is_locked)
  trip_cause = cause or "-"
  if is_locked then
    locked_trip = true
    forced_trip = true
    alarm_locked = true
  else
    forced_trip = true
    alarm_force_until = os.clock() + ALARM_FORCE_SEC
  end
end

local function clear_trip()
  forced_trip = false
  trip_cause = "-"
end

-- =========================
-- ui template
-- =========================
local function draw_template()
  mon.setBackgroundColor(colors.black)
  mon.clear()
  term.setTextColor(colors.lightBlue)
  term.setCursorPos(1, 1)
  term.write("control fission reactor")

  term.setTextColor(colors.gray)
  term.setCursorPos(1, 2)
  term.write(REACTOR_NAME)

  -- left status block
  term.setTextColor(colors.white)
  cwrite(1, 4, colors.white, "auto:")
  cwrite(1, 5, colors.white, "state:")
  cwrite(1, 6, colors.white, "cause:")

  -- center temp
  cwrite(math.floor(W/2) - 6, 6, colors.white, "temp:")

  -- bars labels
  local y0 = 8
  cwrite(1, y0 + 0, colors.white, "coolant")
  cwrite(1, y0 + 1, colors.white, "fuel")
  cwrite(1, y0 + 2, colors.white, "waste")
  cwrite(1, y0 + 3, colors.white, "heated")

  -- values labels
  local yv = y0 + 5
  cwrite(1, yv + 0, colors.lightBlue, "coolant")
  cwrite(1, yv + 1, colors.lime,      "fuel")
  cwrite(1, yv + 2, colors.purple,    "waste")
  cwrite(1, yv + 3, colors.orange,    "heated")
  cwrite(1, yv + 4, colors.white,     "damage")

  cwrite(1, yv + 6, colors.white, "burn:")

  -- footer
  if H >= (yv + 8) then
    cwrite(1, yv + 8, colors.gray, "min burn 10% | forced alarm 3s | locked alarm cont")
  end
end

draw_template()

-- =========================
-- main loop
-- =========================
local last_auto = nil
local last_state = nil
local last_cause = nil
local last_temp = nil
local last_vals = {}

while true do
  local now = os.clock()

  -- auto lever
  local auto = redstone.getInput(AUTO_SIDE) == true

  -- read reactor data (correct mekanism methods)
  local status = safe_call(reactor, "getStatus") -- string or enum-like
  local active = false
  if type(status) == "string" then
    -- common outputs: "running", "idle", "offline", etc
    local s = string.lower(status)
    active = (s == "running") or (s == "active") or (s == "online")
  else
    -- fallback: some packs expose getRedstoneLogicStatus() bool
    local rs = safe_call(reactor, "getRedstoneLogicStatus")
    if type(rs) == "boolean" then active = rs end
  end

  local temp_k = safe_call(reactor, "getTemperature")
  local temp_c = k_to_c(temp_k)

  local coolant_pct = get_pct(reactor, "getCoolantFilled", "getCoolantCapacity", "getCoolantFilledPercentage")
  local fuel_pct    = get_pct(reactor, "getFuelFilled", "getFuelCapacity", "getFuelFilledPercentage")
  local waste_pct   = get_pct(reactor, "getWasteFilled", "getWasteCapacity", "getWasteFilledPercentage")
  local heated_pct  = get_pct(reactor, "getHeatedCoolantFilled", "getHeatedCoolantCapacity", "getHeatedCoolantFilledPercentage")

  local damage_pct  = safe_call(reactor, "getDamagePercent")
  local burn_now    = safe_call(reactor, "getActualBurnRate")
  local burn_max    = safe_call(reactor, "getMaxBurnRate")

  -- safety logic
  if type(damage_pct) == "number" and damage_pct > DAMAGE_LOCK_PCT then
    if not locked_trip then
      set_trip("damage high", true)
    end
  end

  if locked_trip then
    -- absolute stop
    safe_call(reactor, "scram")
  else
    -- trip conditions (forced stop with auto reset)
    if forced_trip == false then
      if type(coolant_pct) == "number" and coolant_pct < COOL_STOP then
        set_trip("coolant low", false)
      elseif type(temp_c) == "number" and temp_c > TEMP_STOP_C then
        set_trip("temp high", false)
      elseif type(heated_pct) == "number" and heated_pct > HEAT_STOP then
        set_trip("heated high", false)
      elseif type(waste_pct) == "number" and waste_pct > WASTE_STOP then
        set_trip("waste high", false)
      end
    end

    -- apply stop if forced
    if forced_trip then
      safe_call(reactor, "scram")
      -- reset conditions
      local can_reset = true

      if trip_cause == "coolant low" then
        can_reset = (type(coolant_pct) == "number" and coolant_pct > COOL_RESET)
      elseif trip_cause == "temp high" then
        can_reset = (type(temp_c) == "number" and temp_c < TEMP_RESET_C)
      elseif trip_cause == "heated high" then
        can_reset = (type(heated_pct) == "number" and heated_pct <= HEAT_RESET)
      elseif trip_cause == "waste high" then
        can_reset = (type(waste_pct) == "number" and waste_pct < WASTE_RESET)
      end

      if can_reset then
        clear_trip()
      end
    end

    -- auto start/stop
    if auto and (not forced_trip) then
      safe_call(reactor, "activate")
    else
      -- if not auto, do not force off (you can keep manual)
      -- uncomment next line if you want auto lever to also stop reactor
      -- safe_call(reactor, "scram")
    end

    -- burn control (only coolant reactive)
    if auto and (not forced_trip) and (type(burn_max) == "number") and burn_max > 0 then
      local min_burn = burn_max * MIN_BURN_FRAC
      local target

      if type(coolant_pct) ~= "number" then
        target = min_burn
      elseif coolant_pct <= COOLANT_LOW then
        target = min_burn
      else
        -- linear scale: at COOLANT_FULL => burn_max
        target = burn_max * (coolant_pct / COOLANT_FULL)
        target = clamp(target, min_burn, burn_max)
      end

      -- ramp to avoid oscillations
      local current = burn_now
      if type(current) ~= "number" then current = 0 end
      local step = burn_max * RAMP_STEP_FRAC
      local delta = target - current
      if delta > step then delta = step end
      if delta < -step then delta = -step end
      local new_burn = clamp(current + delta, 0, burn_max)

      safe_call(reactor, "setBurnRate", new_burn)
    end
  end

  -- update alarms
  update_alarm(now)

  -- =========================
  -- ui update (no flicker)
  -- =========================
  -- auto
  if auto ~= last_auto then
    clear_line(4)
    cwrite(1, 4, colors.white, "auto:")
    cwrite(7, 4, auto and colors.lime or colors.red, auto and "on" or "off")
    last_auto = auto
  end

  -- state text
  local state_txt = "off"
  local state_col = colors.red
  if locked_trip then
    state_txt = "locked"
    state_col = colors.red
  elseif forced_trip then
    state_txt = "forced"
    state_col = colors.red
  else
    if active then
      state_txt = "on"
      state_col = colors.lime
    else
      state_txt = "off"
      state_col = colors.red
    end
  end

  if state_txt ~= last_state then
    clear_line(5)
    cwrite(1, 5, colors.white, "state:")
    cwrite(8, 5, state_col, state_txt)
    last_state = state_txt
  end

  -- cause
  local cause_txt = forced_trip and trip_cause or "-"
  if cause_txt ~= last_cause then
    clear_line(6)
    cwrite(1, 6, colors.white, "cause:")
    cwrite(8, 6, forced_trip and colors.red or colors.gray, cause_txt)
    last_cause = cause_txt
  end

  -- temp
  local temp_txt = "n/a"
  if type(temp_c) == "number" then
    temp_txt = string.format("%.1f c", temp_c)
  end
  if temp_txt ~= last_temp then
    -- temp position
    local tx = math.floor(W/2) - 1
    clear_line(6) -- keep cause? we already redraw line 6, so rewrite both blocks
    -- rewrite left cause line
    cwrite(1, 6, colors.white, "cause:")
    cwrite(8, 6, forced_trip and colors.red or colors.gray, cause_txt)
    -- rewrite temp
    cwrite(math.floor(W/2) - 6, 6, colors.white, "temp:")
    cwrite(math.floor(W/2), 6, colors.orange, temp_txt)
    last_temp = temp_txt
  end

  -- bars + percents
  local y0 = 8
  local bar_x = 9
  local bar_w = math.max(10, W - bar_x - 2)

  local function upd_bar(idx, label, p, col)
    local y = y0 + idx
    local k = label .. "_bar"
    local txt = "[" .. bar(p, bar_w - 2) .. "]"
    if last_vals[k] ~= txt then
      term.setCursorPos(bar_x, y)
      term.setTextColor(colors.gray)
      term.write(txt .. string.rep(" ", math.max(0, W - (bar_x + #txt) + 1)))
      last_vals[k] = txt
    end
  end

  upd_bar(0, "coolant", coolant_pct, colors.lightBlue)
  upd_bar(1, "fuel",    fuel_pct,    colors.lime)
  upd_bar(2, "waste",   waste_pct,   colors.purple)
  upd_bar(3, "heated",  heated_pct,  colors.orange)

  -- percents list
  local yv = y0 + 5
  local vx = 10

  local function upd_val(idx, label, p, col)
    local y = yv + idx
    local txt = fmt_pct(p)
    local k = label .. "_pct"
    if last_vals[k] ~= txt then
      -- clear right side area only
      term.setCursorPos(vx, y)
      term.setTextColor(col)
      term.write(txt .. string.rep(" ", math.max(0, W - (vx + #txt) + 1)))
      last_vals[k] = txt
    end
  end

  upd_val(0, "coolant", coolant_pct, colors.lightBlue)
  upd_val(1, "fuel",    fuel_pct,    colors.lime)
  upd_val(2, "waste",   waste_pct,   colors.purple)
  upd_val(3, "heated",  heated_pct,  colors.orange)

  -- damage
  do
    local y = yv + 4
    local txt = "n/a"
    if type(damage_pct) == "number" then
      txt = string.format("%.1f%%", damage_pct)
    end
    if last_vals["damage"] ~= txt then
      term.setCursorPos(vx, y)
      term.setTextColor(colors.white)
      term.write(txt .. string.rep(" ", math.max(0, W - (vx + #txt) + 1)))
      last_vals["damage"] = txt
    end
  end

  -- burn
  do
    local y = yv + 6
    local txt = "n/a"
    if type(burn_now) == "number" and type(burn_max) == "number" then
      txt = string.format("%.2f / %.2f", burn_now, burn_max)
    end
    if last_vals["burn"] ~= txt then
      clear_line(y)
      cwrite(1, y, colors.white, "burn:")
      cwrite(7, y, colors.yellow, txt)
      last_vals["burn"] = txt
    end
  end

  sleep(LOOP_SEC)
end