-- nuclear.lua (CC:Tweaked + Mekanism Fission Reactor Logic Adapter)
-- Affichage + securites + alarme speaker:
-- - forcedStop (rearmable): alarme 3s au declenchement
-- - lockedStop (absolu/damage): alarme continue jusqu'au redemarrage du programme

-- ====== CONFIG ======
local AUTO_SIDE = "left"      -- levier "Marche Auto"
local LOOP_SEC  = 0.5

-- Seuils securite
local TEMP_TRIP    = 800
local TEMP_RESET   = 100

local COOLANT_TRIP  = 0.05
local COOLANT_RESET = 0.80

local HEATED_TRIP   = 0.80
local HEATED_RESET  = 0.00

local WASTE_TRIP    = 0.80
local WASTE_RESET   = 0.50

local DAMAGE_TRIP   = 30      -- lock: pas de redemarrage auto tant que programme pas relance

-- Alarme
local TEXT_SCALE = 1.5
local BEEP_SOUND = "minecraft:block.note_block.bell"
local BEEP_VOL   = 1.5
local BEEP_PITCH = 1.2

local FORCED_ALARM_SECONDS = 3.0
local FORCED_BEEP_PERIOD   = 0.35   -- rythme bip
local LOCKED_BEEP_PERIOD   = 0.35   -- rythme bip en lock

-- ====== HELPERS ======
local function safeCall(obj, method, ...)
  if not obj or type(obj[method]) ~= "function" then return nil end
  local ok, res = pcall(obj[method], ...)
  if not ok then return nil end
  return res
end

local function clamp01(x)
  if x == nil then return nil end
  if x < 0 then return 0 end
  if x > 1 then return 1 end
  return x
end

local function pctStr(x)
  if x == nil then return "N/A" end
  x = clamp01(x)
  return string.format("%.1f%%", x * 100)
end

local function getCoolantPct(r)
  return clamp01(
    safeCall(r, "getCoolantFilledPercentage") or
    safeCall(r, "getCoolantFillPercentage") or
    safeCall(r, "getCoolantPercentage")
  )
end

local function getFuelPct(r)
  return clamp01(
    safeCall(r, "getFuelFilledPercentage") or
    safeCall(r, "getFuelFillPercentage") or
    safeCall(r, "getFuelPercentage")
  )
end

local function getWastePct(r)
  return clamp01(
    safeCall(r, "getWasteFilledPercentage") or
    safeCall(r, "getWasteFillPercentage") or
    safeCall(r, "getWastePercentage")
  )
end

local function getHeatedCoolantPct(r)
  return clamp01(
    safeCall(r, "getHeatedCoolantFilledPercentage") or
    safeCall(r, "getHeatedCoolantFillPercentage") or
    safeCall(r, "getHeatedCoolantPercentage")
  )
end

local function getTemp(r)
  return safeCall(r, "getTemperature") or safeCall(r, "getTemp")
end

local function getDamage(r)
  return safeCall(r, "getDamage") or safeCall(r, "getDamagePercent") or safeCall(r, "getStructuralIntegrity")
end

local function isActive(r)
  local st = safeCall(r, "getStatus")
  if type(st) == "string" then
    return (st:upper():find("RUN") ~= nil) or (st:upper():find("ON") ~= nil) or (st:upper():find("ACTIVE") ~= nil)
  end
  local a = safeCall(r, "isActive")
  if type(a) == "boolean" then return a end
  a = safeCall(r, "getActive")
  if type(a) == "boolean" then return a end
  return nil
end

local function reactorOn(r)
  if safeCall(r, "activate") ~= nil then return true end
  if safeCall(r, "setActive", true) ~= nil then return true end
  if safeCall(r, "setEnabled", true) ~= nil then return true end
  return false
end

local function reactorOff(r)
  if safeCall(r, "scram") ~= nil then return true end
  if safeCall(r, "deactivate") ~= nil then return true end
  if safeCall(r, "setActive", false) ~= nil then return true end
  if safeCall(r, "setEnabled", false) ~= nil then return true end
  return false
end

-- ====== PERIPHERALS ======
local m = peripheral.find("monitor")
if not m then
  print("ERREUR: Moniteur non detecte.")
  return
end

local r = peripheral.find("fissionReactorLogicAdapter")
if not r then
  print("ERREUR: Fission Reactor Logic Adapter non detecte.")
  return
end

local speaker = peripheral.find("speaker")
if not speaker then
  print("ATTENTION: Speaker non detecte (alarme sonore inactive).")
end

m.setTextScale(TEXT_SCALE)
m.setBackgroundColor(colors.black)
m.clear()

-- ====== STATE ======
local forcedStop = false
local forcedReason = "Aucun"

local lockedStop = false
local lockedReason = "Aucun"

-- Alarm state
local forcedAlarmUntil = 0        -- os.clock() deadline (seconds)
local prevForcedStop = false
local prevLockedStop = false

local function drawLine(y, label, value, color)
  m.setCursorPos(2, y)
  m.setTextColor(colors.white)
  m.write(label)
  m.setCursorPos(24, y)
  m.setTextColor(color or colors.white)
  m.write(value)
end

local function render(autoEnabled, active, temp, coolantPct, fuelPct, wastePct, heatedPct, damage)
  m.setBackgroundColor(colors.black)
  m.clear()
  m.setCursorPos(2,1)
  m.setTextColor(colors.cyan)
  m.write("=== CONTROLE REACTEUR FISSION ===")

  if autoEnabled then
    drawLine(3, "Marche auto:", "ACTIVE", colors.lime)
  else
    drawLine(3, "Marche auto:", "DESACTIVE", colors.red)
  end

  local stateTxt, stateCol
  if lockedStop then
    stateTxt, stateCol = "ARRET ABSOLU", colors.red
  elseif forcedStop then
    stateTxt, stateCol = "ARRET FORCE", colors.red
  else
    if active == true then
      stateTxt, stateCol = "ALLUME", colors.lime
    else
      stateTxt, stateCol = "ETEINT", colors.gray
    end
  end
  drawLine(4, "Etat reacteur:", stateTxt, stateCol)

  if lockedStop then
    drawLine(5, "Cause:", lockedReason, colors.red)
  elseif forcedStop then
    drawLine(5, "Cause:", forcedReason, colors.red)
  else
    drawLine(5, "Cause:", "-", colors.gray)
  end

  drawLine(7,  "Temperature:", temp and (string.format("%.1f C", temp)) or "N/A",
           (temp and temp > TEMP_TRIP) and colors.red or colors.white)

  drawLine(8,  "Coolant:",     pctStr(coolantPct),
           (coolantPct and coolantPct < COOLANT_TRIP) and colors.red or colors.white)

  drawLine(9,  "Fuel:",        pctStr(fuelPct), colors.white)

  drawLine(10, "Waste:",       pctStr(wastePct),
           (wastePct and wastePct > WASTE_TRIP) and colors.red or colors.white)

  drawLine(11, "Heated:",      pctStr(heatedPct),
           (heatedPct and heatedPct > HEATED_TRIP) and colors.red or colors.white)

  drawLine(12, "Damage:",      damage and tostring(damage) or "N/A",
           (damage and damage > DAMAGE_TRIP) and colors.red or colors.white)

  m.setCursorPos(2,14)
  m.setTextColor(colors.gray)
  m.write(string.format("T>%.0f stop/T<%.0f reset | Cool<%.0f%% stop/Cool>%.0f%% reset",
    TEMP_TRIP, TEMP_RESET, COOLANT_TRIP*100, COOLANT_RESET*100))

  m.setCursorPos(2,15)
  m.setTextColor(colors.gray)
  m.write(string.format("Heat>%.0f%% stop/Heat=0%% reset | Waste>%.0f%% stop/Waste<%.0f%% reset | Dmg>%d ABSOLU",
    HEATED_TRIP*100, WASTE_TRIP*100, WASTE_RESET*100, DAMAGE_TRIP))
end

-- ====== ALARM LOOP (speaker) ======
local function alarmLoop()
  while true do
    local now = os.clock()

    -- Priorite: arret absolu => bip infini
    if lockedStop then
      if speaker then
        speaker.playSound(BEEP_SOUND, BEEP_VOL, BEEP_PITCH)
      end
      sleep(LOCKED_BEEP_PERIOD)

    -- Sinon: bip seulement pendant 3 secondes apres declenchement forcedStop
    elseif now < forcedAlarmUntil then
      if speaker then
        speaker.playSound(BEEP_SOUND, BEEP_VOL, BEEP_PITCH)
      end
      sleep(FORCED_BEEP_PERIOD)
    else
      sleep(0.1)
    end
  end
end

-- ====== MAIN LOOP ======
local function mainLoop()
  while true do
    local autoEnabled = redstone.getInput(AUTO_SIDE)

    local temp = getTemp(r)
    local coolantPct = getCoolantPct(r)
    local fuelPct = getFuelPct(r)
    local wastePct = getWastePct(r)
    local heatedPct = getHeatedCoolantPct(r)
    local damage = getDamage(r)
    local active = isActive(r)

    -- ===== LOCKED SAFETY (damage) =====
    if not lockedStop and damage ~= nil and damage > DAMAGE_TRIP then
      lockedStop = true
      lockedReason = "Dommages structurels critiques"
      reactorOff(r)
    end

    -- ===== SAFETY TRIP (rearmable) =====
    if not lockedStop and not forcedStop then
      if temp ~= nil and temp > TEMP_TRIP then
        forcedStop = true
        forcedReason = "Temperature elevee"
        reactorOff(r)

      elseif coolantPct ~= nil and coolantPct < COOLANT_TRIP then
        forcedStop = true
        forcedReason = "Refroidissement insuffisant"
        reactorOff(r)

      elseif heatedPct ~= nil and heatedPct > HEATED_TRIP then
        forcedStop = true
        forcedReason = "Liquide chauffe trop eleve"
        reactorOff(r)

      elseif wastePct ~= nil and wastePct > WASTE_TRIP then
        forcedStop = true
        forcedReason = "Dechets nucleaires trop eleves"
        reactorOff(r)
      end
    end

    -- ===== SAFETY RESET CONDITIONS (hystérésis) =====
    if not lockedStop and forcedStop then
      local tempOk    = (temp == nil) or (temp < TEMP_RESET)
      local coolantOk = (coolantPct == nil) or (coolantPct > COOLANT_RESET)
      local heatedOk  = (heatedPct == nil) or (heatedPct <= HEATED_RESET) -- reset à 0%
      local wasteOk   = (wastePct == nil) or (wastePct < WASTE_RESET)

      if tempOk and coolantOk and heatedOk and wasteOk then
        forcedStop = false
        forcedReason = "Aucun"
      end
    end

    -- ===== TRIGGER ALARMS (edges) =====
    -- Si forcedStop vient juste de passer a true => alarme 3s
    if forcedStop and not prevForcedStop then
      forcedAlarmUntil = os.clock() + FORCED_ALARM_SECONDS
    end

    -- Si lockedStop vient juste de passer a true => on peut aussi lancer un "beep" immediat
    -- (facultatif, car alarmLoop bip deja en continu)
    -- if lockedStop and not prevLockedStop then ... end

    prevForcedStop = forcedStop
    prevLockedStop = lockedStop

    -- ===== AUTO CONTROL =====
    if lockedStop then
      reactorOff(r)
    else
      if not autoEnabled then
        reactorOff(r)
      else
        if not forcedStop then
          reactorOn(r)
        else
          reactorOff(r)
        end
      end
    end

    render(autoEnabled, active, temp, coolantPct, fuelPct, wastePct, heatedPct, damage)
    sleep(LOOP_SEC)
  end
end

parallel.waitForAny(mainLoop, alarmLoop)
