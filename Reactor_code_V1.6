-- reactor_final.lua
-- mekanism fission reactor control (cc:tweaked) + advanced monitor ui
-- fixed: removed setredstonemode/setlogicmode (they caused "found 2 arguments")

-- ===== config =====
local reactor_name  = "fissionReactorLogicAdapter_0"
local monitor_name  = "monitor_7"

local auto_side     = "left"   -- lever for auto mode
local enable_side   = nil      -- set to "back"/"right"/etc if you want an extra enable lever, or keep nil

-- safety thresholds
local temp_stop_c        = 800
local temp_reset_c       = 100

local coolant_stop_pct   = 0.05
local coolant_reset_pct  = 0.80

local heated_stop_pct    = 0.80
local heated_reset_pct   = 0.00

local waste_stop_pct     = 0.80
local waste_reset_pct    = 0.50

local damage_lock_pct    = 30  -- if > 30 => lock stop until program restart

-- burn control by coolant level (keep minimum 10%)
local coolant_full_pct   = 0.80  -- at/above this => max burn
local coolant_low_pct    = 0.10  -- at/below this => min burn
local min_burn_fraction  = 0.10  -- minimum burn = 10% of max burn
local ramp_step          = 0.20  -- max change per loop
local loop_sec           = 0.5

-- alarm
local forced_alarm_sec   = 3     -- forced stop alarm duration
local locked_alarm_loop  = true  -- locked stop = continuous alarm until restart

-- ===== peripherals =====
local reactor = peripheral.wrap(reactor_name)
if not reactor then error("no reactor found: " .. tostring(reactor_name)) end

local mon = peripheral.wrap(monitor_name)
if not mon then error("no monitor found: " .. tostring(monitor_name)) end

local speakers = {}
for _, name in ipairs(peripheral.getNames()) do
  if peripheral.getType(name) == "speaker" then
    speakers[#speakers+1] = peripheral.wrap(name)
  end
end

-- ===== helpers =====
local function safe_call(obj, method, ...)
  if not obj or not method then return nil, "bad_call" end
  local ok, res = pcall(method, obj, ...)
  if ok then return res, nil end
  return nil, res
end

local function k_to_c(k)
  if type(k) ~= "number" then return nil end
  return k - 273.15
end

local function clamp01(x)
  if type(x) ~= "number" then return 0 end
  if x < 0 then return 0 end
  if x > 1 then return 1 end
  return x
end

local function fmt_pct(x)
  if type(x) ~= "number" then return "n/a" end
  return string.format("%.1f%%", x * 100)
end

local function fmt_num(x, d)
  if type(x) ~= "number" then return "n/a" end
  return string.format("%." .. tostring(d or 1) .. "f", x)
end

local function play_alarm()
  if #speakers == 0 then return end
  for _, sp in ipairs(speakers) do
    pcall(function()
      -- try a few sounds, depending on pack/version
      if not sp.playSound("minecraft:block.note_block.pling", 1.0, 1.0) then
        sp.playSound("minecraft:block.note_block.bell", 1.0, 1.0)
      end
    end)
  end
end

-- ===== monitor ui =====
mon.setTextScale(1.0) -- bigger text (adjust 0.5..2.0)
mon.setBackgroundColor(colors.black)
mon.clear()

local function bar(x, y, w, pct, col_fill, col_empty)
  pct = clamp01(pct)
  local fill = math.floor(pct * w + 0.5)
  mon.setCursorPos(x, y)
  for i = 1, w do
    if i <= fill then
      mon.setBackgroundColor(col_fill)
    else
      mon.setBackgroundColor(col_empty)
    end
    mon.write(" ")
  end
  mon.setBackgroundColor(colors.black)
end

local function write_at(x, y, text, col)
  mon.setCursorPos(x, y)
  if col then mon.setTextColor(col) end
  mon.write(text)
  mon.setTextColor(colors.white)
end

local function center(y, text, col)
  local w, _ = mon.getSize()
  local x = math.max(1, math.floor((w - #text) / 2) + 1)
  write_at(x, y, text, col)
end

-- ===== reactor reads (methods that exist on your adapter) =====
local function get_temp_c()
  local k = safe_call(reactor, reactor.getTemperature)
  return k_to_c(k)
end

local function get_status()
  local s = safe_call(reactor, reactor.getStatus)
  return s
end

local function get_coolant_pct()
  local p = safe_call(reactor, reactor.getCoolantFilledPercentage)
  if type(p) == "number" then return clamp01(p) end
  return nil
end

local function get_fuel_pct()
  local p = safe_call(reactor, reactor.getFuelFilledPercentage)
  if type(p) == "number" then return clamp01(p) end
  return nil
end

local function get_waste_pct()
  local p = safe_call(reactor, reactor.getWasteFilledPercentage)
  if type(p) == "number" then return clamp01(p) end
  return nil
end

local function get_heated_pct()
  local p = safe_call(reactor, reactor.getHeatedCoolantFilledPercentage)
  if type(p) == "number" then return clamp01(p) end
  return nil
end

local function get_damage_pct()
  local p = safe_call(reactor, reactor.getDamagePercent)
  if type(p) == "number" then return p end
  return nil
end

local function get_burn_now()
  local b = safe_call(reactor, reactor.getActualBurnRate)
  if type(b) == "number" then return b end
  return 0
end

local function get_burn_max()
  local b = safe_call(reactor, reactor.getMaxBurnRate)
  if type(b) == "number" then return b end
  return 0
end

local function scram()
  pcall(function() reactor.scram() end)
end

local function activate()
  pcall(function() reactor.activate() end)
end

local function set_burn(x)
  pcall(function() reactor.setBurnRate(x) end)
end

-- ===== state =====
local forced_stop = false
local locked_stop = false
local stop_cause  = "-"
local last_forced_alarm_t = 0

local function auto_enabled()
  if auto_side and auto_side ~= "" then
    return redstone.getInput(auto_side) == true
  end
  return false
end

local function system_enabled()
  if not enable_side then return true end
  return redstone.getInput(enable_side) == true
end

local function calc_target_burn(coolant_pct, burn_max)
  if type(coolant_pct) ~= "number" or burn_max <= 0 then return 0 end

  local min_burn = burn_max * min_burn_fraction
  if coolant_pct >= coolant_full_pct then return burn_max end
  if coolant_pct <= coolant_low_pct  then return min_burn end

  local t = (coolant_pct - coolant_low_pct) / (coolant_full_pct - coolant_low_pct)
  return min_burn + t * (burn_max - min_burn)
end

local function ramp(current, target, step)
  if target > current + step then return current + step end
  if target < current - step then return current - step end
  return target
end

local function should_force_stop(temp_c, coolant, heated, waste)
  -- order matters: first match becomes cause
  if type(temp_c) == "number" and temp_c > temp_stop_c then
    return true, "temp_high"
  end
  if type(coolant) == "number" and coolant < coolant_stop_pct then
    return true, "coolant_low"
  end
  if type(heated) == "number" and heated > heated_stop_pct then
    return true, "heated_high"
  end
  if type(waste) == "number" and waste > waste_stop_pct then
    return true, "waste_high"
  end
  return false, "-"
end

local function can_reset_forced(temp_c, coolant, heated, waste, cause)
  if cause == "temp_high" then
    return type(temp_c) == "number" and temp_c < temp_reset_c
  elseif cause == "coolant_low" then
    return type(coolant) == "number" and coolant > coolant_reset_pct
  elseif cause == "heated_high" then
    return type(heated) == "number" and heated <= heated_reset_pct
  elseif cause == "waste_high" then
    return type(waste) == "number" and waste < waste_reset_pct
  end
  return true
end

local function cause_text(c)
  if c == "temp_high" then return "temperature_high" end
  if c == "coolant_low" then return "coolant_low" end
  if c == "heated_high" then return "heated_high" end
  if c == "waste_high" then return "waste_high" end
  if c == "damage_lock" then return "damage_lock" end
  return "-"
end

local function status_text(status, forced, locked)
  if locked then return "locked" end
  if forced then return "forced" end
  -- mekanism often returns "running"/"idle"
  if status == "running" or status == true or status == 1 then return "on" end
  return "off"
end

local function draw_ui(data)
  mon.setBackgroundColor(colors.black)
  mon.clear()

  center(1, "control fission reactor", colors.cyan)
  center(2, reactor_name, colors.gray)

  -- left status
  local a = data.auto and "on" or "off"
  write_at(2, 4, "auto:" .. a, data.auto and colors.lime or colors.red)

  write_at(2, 5, "state:" .. data.state, (data.state == "on") and colors.lime or ((data.state == "forced" or data.state == "locked") and colors.red or colors.lightGray))
  write_at(2, 6, "cause:" .. cause_text(data.cause), colors.yellow)

  -- temp center
  local temp_str = (type(data.temp_c) == "number") and (fmt_num(data.temp_c, 1) .. " c") or "n/a"
  center(8, "temp: " .. temp_str, colors.white)

  -- bars area
  local w, _ = mon.getSize()
  local bar_w = math.max(10, w - 14)
  local bx = 10

  write_at(2, 10, "coolant", colors.lightBlue)
  bar(bx, 10, bar_w, data.coolant or 0, colors.blue, colors.gray)

  write_at(2, 11, "fuel", colors.lime)
  bar(bx, 11, bar_w, data.fuel or 0, colors.green, colors.gray)

  write_at(2, 12, "waste", colors.purple)
  bar(bx, 12, bar_w, data.waste or 0, colors.purple, colors.gray)

  write_at(2, 13, "heated", colors.orange)
  bar(bx, 13, bar_w, data.heated or 0, colors.orange, colors.gray)

  -- values bottom left
  local y0 = 15
  write_at(2, y0+0, "coolant", colors.lightBlue)
  write_at(10, y0+0, fmt_pct(data.coolant), colors.white)

  write_at(2, y0+1, "fuel", colors.lime)
  write_at(10, y0+1, fmt_pct(data.fuel), colors.white)

  write_at(2, y0+2, "waste", colors.purple)
  write_at(10, y0+2, fmt_pct(data.waste), colors.white)

  write_at(2, y0+3, "heated", colors.orange)
  write_at(10, y0+3, fmt_pct(data.heated), colors.white)

  write_at(2, y0+4, "damage", colors.yellow)
  if type(data.damage) == "number" then
    write_at(10, y0+4, string.format("%.1f%%", data.damage), colors.white)
  else
    write_at(10, y0+4, "n/a", colors.white)
  end

  -- burn info
  local burn_line = string.format("burn: %.2f / %.2f", data.burn_now or 0, data.burn_max or 0)
  center(y0+6, burn_line, colors.gray)

  -- error top right (if any)
  if data.err and data.err ~= "" then
    write_at(math.max(1, w - #data.err), 3, data.err, colors.red)
  end

  -- footer
  center(y0+7, "min burn 10% | forced alarm 3s | locked alarm cont", colors.gray)
end

-- ===== main loop =====
while true do
  local err = ""

  -- read sensors
  local temp_c = get_temp_c()
  local coolant = get_coolant_pct()
  local fuel = get_fuel_pct()
  local waste = get_waste_pct()
  local heated = get_heated_pct()
  local damage = get_damage_pct()
  local status = get_status()

  -- lock on damage
  if type(damage) == "number" and damage > damage_lock_pct then
    locked_stop = true
    forced_stop = false
    stop_cause = "damage_lock"
  end

  -- forced stop logic (if not locked)
  if not locked_stop then
    local need_stop, cause = should_force_stop(temp_c, coolant, heated, waste)
    if need_stop then
      forced_stop = true
      stop_cause = cause
    elseif forced_stop then
      -- try reset condition
      if can_reset_forced(temp_c, coolant, heated, waste, stop_cause) then
        forced_stop = false
        stop_cause = "-"
      end
    end
  end

  -- alarms
  local now = os.clock()
  if locked_stop and locked_alarm_loop then
    play_alarm()
  elseif forced_stop then
    if now - last_forced_alarm_t > forced_alarm_sec then
      last_forced_alarm_t = now
    end
    if now - last_forced_alarm_t <= forced_alarm_sec then
      play_alarm()
    end
  end

  -- control outputs
  local auto = auto_enabled()
  local enabled = system_enabled()

  if locked_stop or forced_stop or (not enabled) then
    scram()
    -- keep burn low (optional)
    set_burn(0)
  else
    if auto then
      activate()
      local burn_max = get_burn_max()
      local burn_now = get_burn_now()
      local target = calc_target_burn(coolant, burn_max)
      local next_burn = ramp(burn_now, target, ramp_step)
      set_burn(next_burn)
    else
      -- manual: do not touch reactor state, only show ui
    end
  end

  -- ui data
  local burn_now = get_burn_now()
  local burn_max = get_burn_max()
  local state = status_text(status, forced_stop, locked_stop)

  -- show any read failures as "err"
  -- (optional) if everything is n/a, you can put a hint
  if temp_c == nil and coolant == nil and fuel == nil and waste == nil and heated == nil then
    err = "err: no data"
  end

  draw_ui({
    auto = auto,
    state = state,
    cause = stop_cause,
    temp_c = temp_c,
    coolant = coolant,
    fuel = fuel,
    waste = waste,
    heated = heated,
    damage = damage,
    burn_now = burn_now,
    burn_max = burn_max,
    err = err
  })

  sleep(loop_sec)
end