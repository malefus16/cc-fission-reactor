-- fission reactor control v0 (no uppercase, no accents)

local auto_side = "left"
local loop_sec = 0.5

-- display
local text_scale = 1.0

-- burn rate driven by coolant
local coolant_full = 0.80
local coolant_low = 0.10
local min_burn = 0.10
local ramp_step = 0.20

-- safety thresholds
local temp_stop_c = 800.0
local temp_reset_c = 100.0

local coolant_stop = 0.05
local coolant_reset = 0.80

local heated_stop = 0.80
local heated_reset = 0.00

local waste_stop = 0.80
local waste_reset = 0.50

local damage_stop = 30.0

-- alarms
local beep_sound = "minecraft:block.note_block.bell"
local beep_vol = 1.5
local beep_pitch = 1.2
local forced_alarm_sec = 3.0
local beep_period = 0.35

-- ===== utils =====
local function safe_call(obj, method_name, ...)
  if not obj then return nil end
  local fn = obj[method_name]
  if type(fn) ~= "function" then return nil end
  local ok, res = pcall(fn, obj, ...)
  if not ok then return nil end
  return res
end

local function clamp(x, a, b)
  if x < a then return a end
  if x > b then return b end
  return x
end

local function clamp01(x)
  return clamp(x, 0, 1)
end

local function norm_pct(v)
  if v == nil or type(v) ~= "number" then return nil end
  if v > 1 then v = v / 100 end
  return clamp01(v)
end

local function pct_str(x)
  if x == nil then return "n/a" end
  return string.format("%.1f%%", x * 100)
end

-- ===== method name builder (no uppercase typed) =====
local function c(n) return string.char(n) end

local m = {
  -- reads
  get_temperature = "get" .. c(84) .. "emperature",
  get_coolant_filled_percentage = "get" .. c(67) .. "oolant" .. c(70) .. "illed" .. c(80) .. "ercentage",
  get_fuel_filled_percentage = "get" .. c(70) .. "uel" .. c(70) .. "illed" .. c(80) .. "ercentage",
  get_waste_filled_percentage = "get" .. c(87) .. "aste" .. c(70) .. "illed" .. c(80) .. "ercentage",
  get_heated_coolant_filled_percentage = "get" .. c(72) .. "eated" .. c(67) .. "oolant" .. c(70) .. "illed" .. c(80) .. "ercentage",
  get_damage_percent = "get" .. c(68) .. "amage" .. c(80) .. "ercent",
  get_max_burn_rate = "get" .. c(77) .. "ax" .. c(66) .. "urn" .. c(82) .. "ate",
  get_actual_burn_rate = "get" .. c(65) .. "ctual" .. c(66) .. "urn" .. c(82) .. "ate",
  is_formed = "is" .. c(70) .. "ormed",

  -- actions (already lowercase in mekanism)
  activate = "activate",
  scram = "scram",

  -- write
  set_burn_rate = "set" .. c(66) .. "urn" .. c(82) .. "ate",
}

-- ===== peripherals =====
local mon = peripheral.find("monitor")
local r = peripheral.find("fissionreactorlogicadapter")
local speaker = peripheral.find("speaker")

if not r then
  error("no fissionreactorlogicadapter found")
end

if mon then
  mon.setTextScale(text_scale)
  mon.setBackgroundColor(colors.black)
  mon.clear()
end

-- ===== sensors =====
local function temp_c()
  local k = safe_call(r, m.get_temperature)
  if type(k) ~= "number" then return nil end
  return k - 273.15
end

local function coolant_pct()
  return norm_pct(safe_call(r, m.get_coolant_filled_percentage))
end

local function fuel_pct()
  return norm_pct(safe_call(r, m.get_fuel_filled_percentage))
end

local function waste_pct()
  return norm_pct(safe_call(r, m.get_waste_filled_percentage))
end

local function heated_pct()
  return norm_pct(safe_call(r, m.get_heated_coolant_filled_percentage))
end

local function damage_pct()
  local d = safe_call(r, m.get_damage_percent)
  if type(d) == "number" then return d end
  return nil
end

local function burn_rate()
  local b = safe_call(r, m.get_actual_burn_rate)
  if type(b) == "number" then return b end
  return 0
end

local function max_burn_rate()
  local b = safe_call(r, m.get_max_burn_rate)
  if type(b) == "number" then return b end
  return 0
end

local function is_running()
  return burn_rate() > 0
end

-- ===== control =====
local locked_stop = false
local locked_reason = "none"

local forced_stop = false
local forced_reason = "none"

local forced_alarm_until = 0
local prev_forced = false

local function reactor_on()
  safe_call(r, m.activate)
end

local function reactor_off()
  safe_call(r, m.scram)
end

local function set_burn(v)
  safe_call(r, m.set_burn_rate, v)
end

local function compute_target(maxb, cool)
  if maxb <= 0 then return 0 end
  if cool == nil then return maxb * min_burn end

  local c0 = clamp01(cool)
  if c0 <= coolant_low then return maxb * min_burn end
  if c0 >= coolant_full then return maxb end

  local t = (c0 - coolant_low) / (coolant_full - coolant_low)
  local f = min_burn + t * (1 - min_burn)
  return maxb * f
end

-- ===== ui =====
local function draw_line(y, label, value, col)
  if not mon then return end
  mon.setCursorPos(2, y)
  mon.setTextColor(colors.white)
  mon.write(label)
  mon.setCursorPos(22, y)
  mon.setTextColor(col or colors.white)
  mon.write(tostring(value))
end

local function render(st)
  if not mon then return end
  mon.setBackgroundColor(colors.black)
  mon.clear()

  mon.setCursorPos(2, 1)
  mon.setTextColor(colors.cyan)
  mon.write("control fission reactor")

  draw_line(3, "auto:", st.auto and "on" or "off", st.auto and colors.lime or colors.red)

  local state_txt = "off"
  local state_col = colors.gray
  if st.locked then
    state_txt = "locked stop"
    state_col = colors.red
  elseif st.forced then
    state_txt = "forced stop"
    state_col = colors.red
  elseif st.active then
    state_txt = "on"
    state_col = colors.lime
  end
  draw_line(4, "state:", state_txt, state_col)

  local cause = "-"
  if st.locked then cause = st.locked_reason
  elseif st.forced then cause = st.forced_reason end
  draw_line(5, "cause:", cause, (st.locked or st.forced) and colors.red or colors.gray)

  draw_line(7, "temp:", st.temp_c and string.format("%.1f c", st.temp_c) or "n/a",
    (st.temp_c and st.temp_c > temp_stop_c) and colors.red or colors.white)

  draw_line(8, "coolant:", pct_str(st.coolant), (st.coolant and st.coolant < coolant_stop) and colors.red or colors.white)
  draw_line(9, "fuel:", pct_str(st.fuel), colors.white)
  draw_line(10, "waste:", pct_str(st.waste), (st.waste and st.waste > waste_stop) and colors.red or colors.white)
  draw_line(11, "heated:", pct_str(st.heated), (st.heated and st.heated > heated_stop) and colors.red or colors.white)

  draw_line(12, "damage:", st.damage and string.format("%.1f%%", st.damage) or "n/a",
    (st.damage and st.damage > damage_stop) and colors.red or colors.white)

  draw_line(13, "burn:", string.format("%.2f/%.2f", st.burn or 0, st.maxb or 0), colors.white)
end

-- ===== alarm loop =====
local function alarm_loop()
  while true do
    local now = os.clock()
    if locked_stop then
      if speaker then speaker.playSound(beep_sound, beep_vol, beep_pitch) end
      sleep(beep_period)
    elseif now < forced_alarm_until then
      if speaker then speaker.playSound(beep_sound, beep_vol, beep_pitch) end
      sleep(beep_period)
    else
      sleep(0.1)
    end
  end
end

-- ===== main loop =====
local function main_loop()
  while true do
    local auto = redstone.getInput(auto_side)

    -- optional: check formed
    local formed = safe_call(r, m.is_formed)
    if formed == false then
      -- if not formed, force stop without locking
      forced_stop = true
      forced_reason = "not formed"
      reactor_off()
    end

    local tc = temp_c()
    local cool = coolant_pct()
    local fuel = fuel_pct()
    local waste = waste_pct()
    local heat = heated_pct()
    local dmg = damage_pct()

    -- locked stop on damage
    if (not locked_stop) and dmg ~= nil and dmg > damage_stop then
      locked_stop = true
      locked_reason = "damage high"
      reactor_off()
    end

    -- forced stop conditions (rearmable)
    if (not locked_stop) and (not forced_stop) then
      if tc ~= nil and tc > temp_stop_c then
        forced_stop = true
        forced_reason = "temp high"
        reactor_off()
      elseif cool ~= nil and cool < coolant_stop then
        forced_stop = true
        forced_reason = "coolant low"
        reactor_off()
      elseif heat ~= nil and heat > heated_stop then
        forced_stop = true
        forced_reason = "heated high"
        reactor_off()
      elseif waste ~= nil and waste > waste_stop then
        forced_stop = true
        forced_reason = "waste high"
        reactor_off()
      end
    end

    -- reset forced stop when all ok
    if (not locked_stop) and forced_stop then
      local ok_temp = (tc == nil) or (tc < temp_reset_c)
      local ok_cool = (cool == nil) or (cool > coolant_reset)
      local ok_heat = (heat == nil) or (heat <= heated_reset)
      local ok_waste = (waste == nil) or (waste < waste_reset)

      if ok_temp and ok_cool and ok_heat and ok_waste then
        forced_stop = false
        forced_reason = "none"
      end
    end

    -- start forced alarm for 3s on rising edge
    if forced_stop and (not prev_forced) then
      forced_alarm_until = os.clock() + forced_alarm_sec
    end
    prev_forced = forced_stop

    -- on/off command
    if locked_stop then
      reactor_off()
    elseif (not auto) then
      reactor_off()
    elseif forced_stop then
      reactor_off()
    else
      reactor_on()
    end

    -- burn rate regulation (coolant only)
    if auto and (not forced_stop) and (not locked_stop) then
      local maxb = max_burn_rate()
      local cur = burn_rate()
      local target = compute_target(maxb, cool)
      local diff = clamp(target - cur, -ramp_step, ramp_step)
      set_burn(cur + diff)
    else
      set_burn(0)
    end

    -- render
    local st = {
      auto = auto,
      active = is_running(),
      temp_c = tc,
      coolant = cool,
      fuel = fuel,
      waste = waste,
      heated = heat,
      damage = dmg,
      burn = burn_rate(),
      maxb = max_burn_rate(),
      locked = locked_stop,
      locked_reason = locked_reason,
      forced = forced_stop,
      forced_reason = forced_reason,
    }
    render(st)

    sleep(loop_sec)
  end
end

parallel.waitForAny(main_loop, alarm_loop)
